package cs3500.imageprocessor.model.processor;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedHashMap;import java.util.List;import javax.imageio.ImageIO;import cs3500.imageprocessor.model.effects.blendfilter.BlendingFilter;import cs3500.imageprocessor.model.effects.blendfilter.BrightenBlend;import cs3500.imageprocessor.model.effects.blendfilter.TransparentView;import cs3500.imageprocessor.model.effects.singlelayer.BrightenIntensity;import cs3500.imageprocessor.model.effects.singlelayer.BrightenValue;import cs3500.imageprocessor.model.effects.blendfilter.DarkenBlend;import cs3500.imageprocessor.model.effects.singlelayer.DarkenIntensity;import cs3500.imageprocessor.model.effects.singlelayer.DarkenLuma;import cs3500.imageprocessor.model.effects.singlelayer.DarkenValue;import cs3500.imageprocessor.model.effects.singlelayer.GreenComponent;import cs3500.imageprocessor.model.effects.blendfilter.Inversion;import cs3500.imageprocessor.model.effects.singlelayer.SingleLayerFilter;import cs3500.imageprocessor.model.effects.singlelayer.Normal;import cs3500.imageprocessor.model.effects.singlelayer.RedComponent;import cs3500.imageprocessor.model.functions.FunctionUtils;import cs3500.imageprocessor.model.image.Image;import cs3500.imageprocessor.model.image.ImageImpl;import cs3500.imageprocessor.model.image.Layer;import cs3500.imageprocessor.model.image.LayerImpl;import cs3500.imageprocessor.model.image.Pixel;import cs3500.imageprocessor.model.image.PixelImpl;import cs3500.imageprocessor.model.effects.singlelayer.BlueComponent;import cs3500.imageprocessor.model.effects.singlelayer.BrightenLuma;import cs3500.imageprocessor.model.image.ImageUtil;/** * This class represents a model for an image processor. * It contains a map of layers. * It also contains the width and height of the project. * It can add layers, remove layers, and get the layers. * It can also get the width and height of the project. * It can also save the project as a text file. * It can also load a project from a text file. */public class ImageProcessorModelImpl implements ImageProcessorModel<Layer, Image, Pixel,        SingleLayerFilter, BlendingFilter> {  private final LinkedHashMap<String, Layer> layerMap;  private Layer currentLayer;  private int width;  private int height;  /**   * Constructs an image processor model with the given width and height.   * Adds a default LinkedHashMap.   *   * @param width  the width of the project.   * @param height the height of the project.   */  public ImageProcessorModelImpl(int width, int height) {    this.width = width;    this.height = height;    layerMap = new LinkedHashMap<>();    this.newProject(width, height);  }  /**   * Constructs an image processor model with no width or height. Adds a default LinkedHashMap.   */  public ImageProcessorModelImpl() {    layerMap = new LinkedHashMap<>();  }  @Override  public void newProject(int width, int height) throws IllegalStateException,          IllegalArgumentException {    if (layerMap.size() > 0) {      throw new IllegalStateException("Cannot create new project with existing layers");    }    if (width <= 0 || height <= 0) {      throw new IllegalArgumentException("Width and height must be positive");    }    List<List<Pixel>> imageGrid = new ArrayList<>();    for (int i = 0; i < height; i++) {      List<Pixel> row = new ArrayList<>();      for (int j = 0; j < width; j++) {        row.add(new PixelImpl(255, 255, 255));      }      imageGrid.add(row);    }    this.width = width;    this.height = height;    this.layerMap.put("Background", new LayerImpl(            "Background", new ArrayList<>(List.of(new ImageImpl(            imageGrid, 0, 0, width, height,            255))),            width, height));    this.currentLayer = this.layerMap.get("Background");  }  @Override  public String getName(Layer layer) {    return layer.getName();  }  @Override  public String getFilter(Layer layer) {    return layer.getFilter().getName();  }  @Override  public int getWidth() {    return this.width;  }  @Override  public int getHeight() {    return this.height;  }  @Override  public void addLayer(String layerName) {    if (this.layerMap.get(layerName) != null) {      this.layerMap.remove(layerName);    }    List<List<Pixel>> imageGrid = new ArrayList<>();    for (int i = 0; i < height; i++) {      List<Pixel> row = new ArrayList<>();      for (int j = 0; j < width; j++) {        row.add(new PixelImpl(0, 255, 255, 255));      }      imageGrid.add(row);    }    this.layerMap.put(layerName, new LayerImpl(            layerName, new ArrayList<>(List.of(new ImageImpl(            imageGrid, 0, 0, width, height,            255))),            width, height));    this.currentLayer = this.layerMap.get(layerName);    this.applyBlendingFunction("transparent-view", layerName);  }  @Override  public Layer getCurrentLayer() throws IllegalAccessException {    if (this.currentLayer == null) {      throw new IllegalAccessException("No current layer");    }    return this.currentLayer;  }  @Override  public void setCurrentLayer(String key) {    this.currentLayer = layerMap.get(key);  }  @Override  public Layer getLayer(String key) {    return layerMap.get(key);  }  @Override  public List<Layer> getLayers() {    return new ArrayList<>(layerMap.values());  }  @Override  public boolean hasKey(String key) {    for (String str : layerMap.keySet()) {      if (str.equals(key)) {        return true;      }    }    return false;  }  @Override  public int getLayerWidth(String layerName) {    return layerMap.get(layerName).getWidth();  }  @Override  public int getLayerHeight(String layerName) {    return layerMap.get(layerName).getHeight();  }  @Override  public int getLayerMaxValue(String layerName) {    return layerMap.get(layerName).getMaxValue();  }  @Override  public int getMaxValue() {    int maxValue = 0;    for (Layer layer : layerMap.values()) {      maxValue = Math.max(maxValue, layer.getMaxValue());    }    return maxValue;  }  @Override  public List<List<Pixel>> create2DArray(List<Pixel> flatList, int width, int height) {    List<List<Pixel>> gridList = new ArrayList<>();    int count = 0;    for (int i = 0; i < height; i++) {      List<Pixel> row = new ArrayList<>();      for (int j = 0; j < width; j++) {        row.add(flatList.get(count));        count++;      }      gridList.add(row);    }    return gridList;  }  @Override  public Image applyFilter(SingleLayerFilter func, Image image) {    List<Pixel> flatList = image.flattenList();    List<Pixel> flatList2 = new ArrayList<>();    for (Pixel pixel : flatList) {      Pixel pixel2 = func.apply(pixel);      flatList2.add(pixel2);    }    List<List<Pixel>> gridList = create2DArray(flatList2, image.getWidth(), image.getHeight());    return new ImageImpl(gridList, image.getXLoc(), image.getYLoc(),            image.getWidth(), image.getHeight(),            image.getMaxValue());  }  @Override  public void applyFunction(String functionName, String layerName) {    SingleLayerFilter function;    switch (functionName.toLowerCase()) {      case "red-component":        function = new RedComponent();        break;      case "green-component":        function = new GreenComponent();        break;      case "blue-component":        function = new BlueComponent();        break;      case "brighten-value":        function = new BrightenValue();        break;      case "brighten-intensity":        function = new BrightenIntensity();        break;      case "brighten-luma":        function = new BrightenLuma();        break;      case "darken-value":        function = new DarkenValue();        break;      case "darken-intensity":        function = new DarkenIntensity();        break;      case "darken-luma":        function = new DarkenLuma();        break;      case "normal":        function = new Normal();        break;      default:        throw new IllegalArgumentException("Invalid function name");    }    Layer layer = layerMap.get(layerName);    layer.setFilter(function);    layer.getImages().replaceAll(image -> applyFilter(function, image));  }  @Override  public Image applyBlendingFilter(BlendingFilter func, Image topImage, Image botImage) {    List<Pixel> flatList = new ArrayList<>();    for (int j = topImage.getYLoc(); j < topImage.getHeight() + topImage.getYLoc(); j++) {      for (int i = topImage.getXLoc(); i < topImage.getWidth() + topImage.getXLoc(); i++) {        Pixel topPixel = topImage.getPixel(i, j);        if (botImage.inBounds(i, j, botImage.getWidth(), botImage.getHeight())) {          Pixel botPixel = botImage.getPixel(i, j);          Pixel newPixel = func.apply(topPixel, botPixel);          flatList.add(newPixel);        } else {          flatList.add(topPixel);        }      }    }    List<List<Pixel>> gridList = create2DArray(flatList, topImage.getWidth(), topImage.getHeight());    return new ImageImpl(gridList, topImage.getXLoc(), topImage.getYLoc(),            topImage.getWidth(), topImage.getHeight(),            topImage.getMaxValue());  }  @Override  public void applyBlendingFunction(String filterName, String topLayer) {    BlendingFilter function;    switch (filterName.toLowerCase()) {      case "inversion":        function = new Inversion();        break;      case "brighten-blend":        function = new BrightenBlend();        break;      case "darken-blend":        function = new DarkenBlend();        break;      case "transparent-view":        function = new TransparentView();        break;      default:        throw new IllegalArgumentException("Invalid function name");    }    Layer layer = layerMap.get(topLayer);    List<Layer> layerList = this.getLayers();    int index = layerList.indexOf(layer);    if (index == 0) {      return;    }    Layer bottomLayer = layerList.get(index - 1);    List<Pixel> botPixels = bottomLayer.getPixels();    Image bottomImage = new ImageImpl(create2DArray(botPixels, bottomLayer.getWidth(),            bottomLayer.getHeight()), 0, 0,            bottomLayer.getWidth(), bottomLayer.getHeight(), bottomLayer.getMaxValue());    layer.setFilter(function);    layer.getImages().replaceAll(image -> applyBlendingFilter(function, image, bottomImage));  }  @Override  public void addPPMImageToLayer(String layerName, String fileLoc, int xLoc, int yLoc)          throws IOException {    Image image = ImageUtil.readPPM(fileLoc, fileLoc);    Layer layer = layerMap.get(layerName);    layer.addImage(image, xLoc, yLoc);  }  @Override  public void addImageToLayerWithImage(String layerName, Image image, int xLoc, int yLoc) {    Layer layer = layerMap.get(layerName);    layer.addImage(image, xLoc, yLoc);  }  @Override  public void addJPGImageToLayer(String layerName, String fileLoc, int xLoc, int yLoc)          throws IOException {    BufferedImage image = ImageIO.read(new File(fileLoc));    List<List<Pixel>> pixelGrid = FunctionUtils.createImageGrid(image);    Image image2 = new ImageImpl(pixelGrid, xLoc, yLoc, image.getWidth(),            image.getHeight(), 255);    Layer layer = layerMap.get(layerName);    layer.addImage(image2, xLoc, yLoc);  }  @Override  public void addPNGImageToLayer(String layerName, String fileLoc, int xLoc, int yLoc)          throws IOException {    BufferedImage image = ImageIO.read(new File(fileLoc));    List<List<Pixel>> pixelGrid = FunctionUtils.createAlphaImageGrid(image);    Image image2 = new ImageImpl(pixelGrid, xLoc, yLoc, image.getWidth(),            image.getHeight(), 255);    Layer layer = layerMap.get(layerName);    layer.addImage(image2, xLoc, yLoc);  }  @Override  public void addImageToLayer(String layerName, String fileLoc, int xLoc, int yLoc)          throws IOException {    System.out.println(fileLoc);    List<String> liststring = Arrays.asList(fileLoc.split("[.]"));    String fileType = liststring.get(liststring.size() - 1);    System.out.println(fileType);    if (fileType.equals("ppm")) {      addPPMImageToLayer(layerName, fileLoc, xLoc, yLoc);    } else if (fileType.equalsIgnoreCase("png")) {      addPNGImageToLayer(layerName, fileLoc, xLoc, yLoc);    } else if (fileType.equalsIgnoreCase("jpg")            || fileType.equalsIgnoreCase("jpeg")) {      addJPGImageToLayer(layerName, fileLoc, xLoc, yLoc);    } else {      throw new IllegalArgumentException("Invalid file type");    }    this.applyBlendingFunction("transparent-view", layerName);  }  @Override  public boolean hasFilter(String filterName) {    return filterName.equals("red-component") || filterName.equals("green-component")            || filterName.equals("blue-component") || filterName.equals("brighten-value")            || filterName.equals("brighten-intensity") || filterName.equals("brighten-luma")            || filterName.equals("darken-value") || filterName.equals("darken-intensity")            || filterName.equals("darken-luma") || filterName.equals("normal")            || filterName.equals("inversion") || filterName.equals("brighten-blend")            || filterName.equals("darken-blend");  }  @Override  public void loadProject(String fileLoc, String layerName) throws IOException,          IllegalStateException, IllegalArgumentException {    if (this.layerMap.size() > 0) {      throw new IllegalStateException("Cannot load project into non-empty model");    }    String fileType = fileLoc.split("[.]")[1];    if (fileType.equals("txt")) {      loadCollage(fileLoc);    } else if (fileType.equals("ppm")) {      loadPPM(fileLoc, layerName);    } else if (fileType.equalsIgnoreCase("png")            || fileType.equalsIgnoreCase("jpg")            || fileType.equalsIgnoreCase("jpeg")) {      loadImage(fileLoc, layerName);    } else {      throw new IllegalArgumentException("Not a valid file type");    }  }  @Override  public void loadImage(String fileLoc, String layerName) throws IOException {    BufferedImage image = ImageIO.read(new File(fileLoc));    if (image == null) {      throw new IllegalArgumentException("Not a valid file");    }    this.width = Math.max(this.width, image.getWidth());    this.height = Math.max(this.height, image.getHeight());    this.addLayer(layerName);    List<List<Pixel>> pixelGrid = FunctionUtils.createAlphaImageGrid(image);    this.addImageToLayerWithImage(layerName, new ImageImpl(pixelGrid, 0, 0,            image.getWidth(), image.getHeight(), 255), 0, 0);  }  @Override  public void loadPPM(String filename, String layerName) throws IOException {    try {      Image image = ImageUtil.readPPM(filename, filename);      if (image == null) {        throw new IllegalArgumentException("Not a valid file");      }      this.width = Math.max(this.width, image.getWidth());      this.height = Math.max(this.height, image.getHeight());      this.addLayer(layerName);      this.addImageToLayerWithImage(layerName, image, 0, 0);      this.currentLayer = this.layerMap.get(layerName);    } catch (IOException e) {      throw new IOException("Not a valid file");    }  }  @Override  public void loadCollage(String filename) throws IOException {    List<Layer> layers = ImageUtil.readCollage(filename);    if (layers == null) {      throw new IllegalArgumentException("Not a valid file");    }    for (Layer layer : layers) {      this.layerMap.put(layer.getName(), layer);      this.width = Math.max(this.width, layer.getWidth());      this.height = Math.max(this.height, layer.getHeight());    }    this.currentLayer = layers.get(0);  }  @Override  public void save(String location) throws IOException, IllegalAccessException {    String fileType = location.split("[.]")[1];    if (fileType.equalsIgnoreCase("jpg")            || fileType.equalsIgnoreCase("jpeg")) {      saveJPG(location);    } else if (fileType.equalsIgnoreCase("png")) {      savePNG(location);    } else if (fileType.equalsIgnoreCase("ppm")) {      savePPM(location);    } else {      throw new IllegalArgumentException("Not a valid location");    }  }  @Override  public void saveJPG(String location) {    String fileType = location.split("[.]")[1];    BufferedImage image = new BufferedImage(this.getWidth(), this.getHeight(),            BufferedImage.TYPE_INT_RGB);    setPixels(location, fileType, image);  }  @Override  public void savePNG(String location) {    String fileType = location.split("[.]")[1];    BufferedImage image = new BufferedImage(this.getWidth(), this.getHeight(),            BufferedImage.TYPE_INT_ARGB);    setPixels(location, fileType, image);  }  /**   * Sets the pixels of the image to the pixels of the current layer.   *   * @param location the location of the file   * @param fileType the type of the file   * @param image    the image to be saved   */  private void setPixels(String location, String fileType, BufferedImage image) {    for (int i = 0; i < this.getWidth(); i++) {      for (int j = 0; j < this.getHeight(); j++) {        image.setRGB(i, j, this.currentLayer.getPixel(i, j).getRGB());      }    }    try {      ImageIO.write(image, fileType, new File(location));    } catch (IOException e) {      e.printStackTrace();    }  }  @Override  public void saveCollage(String location) throws IOException, IllegalArgumentException {    String fileType = location.split("[.]")[1];    if (!fileType.equals("txt")) {      throw new IllegalArgumentException("Not a valid location");    } else {      File newFile = new File(location);      FileWriter writer = new FileWriter(newFile);      writer.write("C1\n");      writer.write(this.getWidth() + " " + this.getHeight() + "\n");      writer.write(getMaxValue() + "\n");      for (Layer layer : this.getLayers()) {        writer.write(layer.getName() + " " + layer.getFilter().getName() + "\n");        for (Pixel pixel : layer.getPixels()) {          writer.write(pixel.getRed() + " " + pixel.getGreen() + " "                  + pixel.getBlue() + " " + pixel.getAlpha() + "\n");        }      }      writer.close();    }  }  @Override  public void savePPM(String location) throws IOException, IllegalAccessException {    File newFile = new File(location);    FileWriter writer = new FileWriter(newFile);    writer.write("P3\n");    writer.write(width + " " + height + "\n");    writer.write(this.currentLayer.getMaxValue() + "\n");    Layer layer = this.getCurrentLayer();    for (Pixel pixel : layer.getPixels()) {      writer.write(pixel.getRed() + " " + pixel.getGreen() + " "              + pixel.getBlue() + "\n");    }    writer.close();  }  @Override  public List<List<Pixel>> getImage() {    return create2DArray(currentLayer.getPixels(), this.width, this.height);  }}